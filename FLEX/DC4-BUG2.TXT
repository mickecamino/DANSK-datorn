
** INIT SYSTEM POVER ON
*
SYSINT LDA #%10010010     T[ND SYSTEM MED REL[
 STA VIA+2
 LDB #%00010010
 STB VIA

** SYSTEM POVER ON DELAY
*
 LDA SYSBYT
 CMPA #$5A
 BEQ INSTRM
PDEL0 LDX #$5000
PDEL1 LEAX 1,X
 BNE PDEL1
 DECB
 BNE PDEL0

** INIT DATRAM
*
INSTRM LDA #$0D
 STA IC11+$D
INRMDF LDX #IC11
 LDY #LRARAM
 CLRA
INRMLP STA 0,X+
 STA 0,Y+
 INCA
 CMPA #$10
 BNE INRMLP

 LDS #STACK

** INIT SYSTEMRAM
*
INTRAM LDA SYSBYT
 CMPA #$5A
 BNE INTDEF
 LDY #TIME
 BRA INRAM0
INTDEF LDY #EXTBYT
INRAM0 CLRA
INRAM1 STA 0,Y+
 CMPY #INVEC
 BNE INRAM1
 LDX #RAMPON
INRAM2 LDA 0,X+
 CMPX #POIEND
 BEQ INRAM3
 STA 0,Y+
 BRA INRAM2
INRAM3 JSR TSTR12         EPROM #12 ?

** INIT RAMVECTOR
*
MONITOR LDY #ROMVEC
 LDX #RAMVEC
 LDB #$10
PSS LDA ,Y+
 STA ,X+
 DECB
 BNE PSS
 LDX #ACIA1
 STX CPORT

** INIT IO-KREDSE
*
 JSR CRTINT         INIT CRT
 JSR INTACA         INIT ACIA
 LDX #$4000
TSTRTC LDA RTC
 ANDA #$0F
 BEQ SYINTS
 DEX
 BNE TSTRTC
 STA RTCBYT
SYINTS LDA #$20
 LDX #$E800
CLSKRF STA 0,X+
 CMPX #$F000
 BNE CLSKRF

** TEST FOR MONITOR VED POVER ON
*
 JSR POCHK
 BEQ IOINT1
 JMP SYSMON

 FCB $20

** TEST FOR FLEX I EPROM
*
IOINT1 LDA VIA
 ANDA #%00000100
 LBEQ EPRIND

** HENT FLEX IND
*
BOOT0 LDA #$7E FIXA ]TERSTART
 LDY #$C000
 STA 0,Y
 LDX #BOOT2
 STX 1,Y
BOOT2 LDU #FLOPPY
 LDA SYSBYT
 CMPA #$5A
 BEQ BOOT3
 LDB #$D8 FORCE INTERRUPT  VED POVER ON
 STB $4,U COMREG
BOOT3 CLRA
 LDX #0
OVR STA $0,U DRIVE #0 MOTOR ON
 LEAX 1,X
 BNE OVR
 LDB #$0F RESTORE TO TRACK 00
 STB $4,U COMREG TURN MOTOR ON
 BSR BOTRTS
LOOP1 LDB $4,U COMREG
 BITB #1 BUSY ?
 BNE LOOP1
 LDA #1
 STA $6,U SECREG
 BSR BOTRTS
 LDA #$8C READ W LOAD
 STA $4,U COMREG
 BSR BOTRTS
 LDB $4,U STATUSREG
LOOP2 BITB #2 DRQ?
 BEQ LOOP3
 LDA $7,U DATREG
 STA 0,Y+
LOOP3 LDB $4,U STATUSREG
 BITB #1 BUSY ?
 BNE LOOP2
 JMP $C000
*
BOTRTS BSR BOOT49
BOOT49 BSR BOOT39
BOOT39 BSR BOOTRT
BOOTRT RTS

*
MSG2 FCB $D,$A,4

**
*
BYTES BSR INHEX GET HEX LEFT
 BVS NORTS EXIT IF NOT VALID HEX
 ASLA
 ASLA
 ASLA SHIFT INTO LEFT NIBBLE
 ASLA
 TFR A,B PUT HEXL IN "B"
 BSR INHEX GET HEX RIGHT
 BVS NORTS EXIT IF NOT VALID HEX
 PSHS B PUSH HEXL ON STACK
 ADDA ,S+ ADD HEXL TO HEXR AND ADJ. STK
 RTS RETURN WITH HEX L&R IN "A"

**
*
INHEX BSR ECHON INPUT ASCII CHAR.
INHEX1 CMPA #'0 IS IT > OR = "0" ?
 BCS NOTHEX IF LESS IT AIN'T HEX
 CMPA #'9 IS IT < OR = "9" ?
 BHI INHEXA IF > MAYBE IT'S ALPHA
 SUBA #$30 ASCII ADJ. NUMERIC
RTS RTS

**
*
INHEXA CMPA #'A IS IT > OR = "A"
 BCS NOTHEX IF LESS IT AIN'T HEX
 CMPA #'F IS IT < OR = "F" ?
 BHI NOTHEX IF > IT AIN'T HEX
 SUBA #$37 ASCII ADJ. ALPHA
 RTS

NOTHEX ORCC #2 SET (V) FLAG IN C-CODES REGISTER
NORTS RTS

* *** INCHP GETS A CHARACTER FROM THE TERMINAL
* AND STRIPS PARITY FROM THE CHARACTER. IT
* THEN TESTS TO SEE IF ECHO IS REQUIRED. IF
* ECHO IS REQUIRED THE CHARACTER IS ECHOED
* AND THEN THE CHARACTER IS RETURNED IN THE
* "A" ACCUMULATOR WITH PARITY STRIPPED.

INCHPS BSR INCH GET CHAR
 ANDA #$7F STRIP PARITY
 RTS

**
*
INCHP BSR INCHPS GET CHAR
 TST ECHO IS ECHO REQUIRED ?
 LBNE OUTCH ECHO IF REQUIRED
 RTS

**
*
INCHPH BSR INCHP
 BRA INHEX1 TEST FOR LEGAL HEX

* GET CHARACTER FROM TERMINAL. RETURN
* CHARACTER IN "A" ACCUMULATOR AND PRESERVE
* ALL OTHER REGISTERS. THE INPUT CHARACTER
* IS 8 BITS AND IS NOT ECHOED.

INCH PSHS X
 JMP [INVEC]
INHUP LDX CPORT
GESTA LDA 0,X
 ANDA #$01
 BEQ GESTA
 LDA 1,X
 BMI COKAR
 CMPA #$15          FUNKTIONS TAST
 BEQ FUNKEU         ^U
 CMPA #$1B          ESC
 BNE NOESC
 JMP [ESCVEC]
 NOP
 NOP
NOESC CMPA #$1F          CONTROL TAST
 BLS COKAR
INRTS PULS X,PC

* CHECK FOR A CHARACTER AVAILABLE FROM
* THE TERMINAL. THE SERIAL PORT IS CHECKED
* FOR READ READY. ALL REGISTERS ARE
* PRESERVED, AND THE "Z" BIT WILL BE
* CLEAR IF A CHARACTER CAN BE READ.
*
INCHEK PSHS X,A
 LDX CPORT
 LDA 0,X
 BITA #$01
 PULS X,A,PC

**
*
ECHON TST ECHO IS ECHO REQUIRED ?
 BEQ INCH ECHO NOT REQ. IF CLEAR

* INCHE GETS CHARACTER FROM TERMINAL AND
* ECHOS SAME. THE CHARACTER IS RETURNED
* IN THE "A" ACCUMULATOR WITH THE PARITY
* BIT MASKED OFF. ALL OTHER REGISTERS
* ARE PRESERVED.

INCHE BSR INCHPS GET CHAR FROM TERMINAL
 JMP OUTCH

** TEST FOR FUNKTIONS TASTER
*
COKAR JMP [KEYVEC]
KTAB1 LDX #KEYCON
COKAR1 CMPA ,X+
 BEQ GOKART
 INX
 CMPX #KEYTEN
 BNE COKAR1
 BRA GOKEND

GOKART LDA 0,X
 BMI INDFUN         FUNKTIONS TAST ?
GOKEND PULS X,PC

**
*
INDFUN JSR SETL25
 CMPA #$FE          SET CLOCK ON
 BEQ FUNKR
 CMPA #$FC          BLANK SK[RM
 BEQ FUNKC
 CMPA #$FD          S[T FUNKTION
 BEQ FUNFUN
 CMPA #$FF          SET CLOCK OFF
 BEQ FUNKO
 JSR CLRL25
 PULS X,PC

FUNKEU JSR SETL25
FUNFUN LDX #FUNKMG
 JSR PDATA0
 JSR INCHNO
 CMPA #'R
 BEQ FUNKR
 CMPA #'O
 BEQ FUNKO
 CMPA #'C
 BEQ FUNKC
 JMP [FUNVEC]

EXTFUN JSR TSTR12
 BNE FUNEND
 STA EXTBYT
 PSHS B
 LDB #12
 LDX #$0E30
 JMP RDPROM

FUNEND JSR CLRL25
 JMP INHUP

** FUNKTION R
*
FUNKR JSR SETRTC    S[T CLOCK ON
 BRA FUNEND

** FUNKTION O
*
FUNKO JSR NORTC     S[T CLOCK OFF
 BRA FUNEND

** FUNKTION C
** BLANK SK[RM
*
FUNKC LDA #1
 STA CLSBY1
 JSR FCLSC
 BRA FUNEND

** SKRIV DATA TIL RTC
*
RTCWRT PSHS CC
 ORCC #%01010000
 JSR RTCDEL   DELAY FOR READY
RTCWR1 LDA #$0F           RESET RTC
 STA RTC
 LDA RTCBTT
 STA RTC
 LDA RTCBTU         TIMER RUN
 STA RTC
 PULS CC,PC

** L[S STATUS FRA RTC TIL A-REG
*
RTCRST PSHS CC
 ORCC #%01010000
 BSR RTCDEL
 LDA #$0F
 STA RTC
 LDA RTC
 ASLA
 ASLA
 ASLA
 ASLA
 STA WRKSPC
 LDA RTC
 ANDA #$0F
 ORA WRKSPC
 PULS CC,PC

** NULSTIL OG START TIMER
*
RTCTIS PSHS CC
 ORCC #%01000000
 BSR RTCDEL
 CLRA
 LDB #12
LTIM1 STB RTC
 STA RTC
 STA RTC
 INCB
 CMPB #15
 BNE LTIM1
 LDA RTCBTT
 ANDA #%00000110
 ORA #%00000001
 STA RTCBTT
 BRA RTCWR1

** L[S RTC TIL RAM
*
RTCSET PSHS CC,A,B,X,Y
 ORCC #%01000000
 BSR RTCDEL         HENT DATA
 LDX #TIME          RAMTABEL
 LDY #RTCTAB        ROMTABEL
RTC1 LDB 0,Y+
 BMI RTC4
 CMPB #$10
 BEQ RTCEND
 STB RTC
 LDA RTC
 ANDA #$0F
 ORA #$30
 STA 0,X+
 LDA RTC
 ANDA #$0F
 ORA #$30
RTC3 STA 0,X+
 BRA RTC1
RTC4 SUBB #$80
 STB 0,X+
 BRA RTC1
RTCEND PULS CC,A,B,X,Y,PC

** RTC DELAY ROUTINE
*
RTCDEL PSHS A,X
 TST RTCBYT
 BNE RDEL5
RDEL1 LDA RTC
 ANDA #$0F
 BNE RDEL1
 LDX #$10
RDEL2 DEX
 BNE RDEL2
 LDA RTC
 ANDA #$0F
 BNE RDEL1
RDEL5 PULS A,X,PC

RTCTAB FCB 3,$AD,4,$AD,5,$80,2,$BA,1,$BA,0,$80,6,7
 FCB 14,$BA,13,$BA,12,$80,11,10,9,8,$10


** BLANK SK[RM EFTER 30 MIN
*

SCRIRQ DEC CLSBY1
 BNE FIRRTS
 BSR FCLSC
FIRRTS RTI

FCLSC PSHS CC,A,B,X,Y
 ORCC #%01010000  MASK FIRQ + IRQ
 COM SCEFLG
 LDA #$0E
 STA IC11
 JSR CUROF1
 LDB #$20
 LDY #0
 LDX #CRTRAM
SIRQ1 LDA 0,X
 STB 0,X
 STA 0,Y+
 INX
 CMPX #$F000
 BNE SIRQ1
 LDA LRARAM
 STA IC11
 CLI              CLEAR IRQ
 LDY #CRTRAM
SIRQ4 LDX #$5000
 LDA #'.
 STA 0,Y
 JSR [CLRVEC]
 BNE SIRQ7
SIRQ3 DEX
 BNE SIRQ3
 LDA #$20
 STA 0,Y+
 CMPY #RAMEND
 BNE SIRQ4
 LDY #CRTRAM
 BRA SIRQ4
SIRQ7 SEI         MASK IRQ
 LDA #$0E
 STA IC11
 LDX #CRTRAM
 LDY #$0000
SIRQ8 LDA 0,Y+
 STA 0,X+
 CMPX #LINE25+80
 BNE SIRQ8
 LDA #30
 STA CLSBY1
 LDA LRARAM
 STA IC11
 CLI
 JSR CURON1
 LDA ACIA1+1      CLEAR ACIA
 CLR SCEFLG
 PULS CC,A,B,X,Y,PC

** S[T CLOCK OFF OG PULSE TIL 1 MINUT
*
NORTC PSHS A,B
 LDA RTCBTT
 ANDA #%00000001
 ORA #%00000101      PULSE 1 MINUT
 STA RTCBTT
 JSR RTCWRT
 LDD #SCRIRQ
 STD FIRQ
 LDX RTCLOC
 CLRB
CLRTCL CLR B,X
 INCB
 CMPB #8
 BNE CLRTCL
 CLR CLKBYT
 PULS A,B,PC

** SET CLOCK ON
*
SETRTC PSHS A,X
 LDA RTCBTT
 ANDA #%00000001
 ORA #%00000010
 STA RTCBTT
 JSR RTCWRT
 BSR RTCOU1
 LDX #RTCOUT
 STX FIRQ
 COM CLKBYT
 ANDCC #%00010000    FIRQ ON
 PULS A,X,PC

** FIRQ ROUTINE FOR CLOCK
*
RTCOUT PSHS A
 BSR RTCOU1
 DEC CLSBY2
 BNE NOSLSK
 LDA #60
 STA CLSBY2
 PULS A
 JMP SCRIRQ
NOSLSK PULS A
 RTI

RTCOU1 PSHS A,X,Y
 JSR RTCSET
 LDY RTCLOC
 LDX #RTCTIM
RTCO1 LDA 0,X+
 CMPX #WEEKD+1
 BEQ RTOUE
 STA 0,Y+
 BRA RTCO1
RTOUE PULS A,X,Y,PC

**
*
EPRIND LDB #13
 LDX #0

** B=EPROMNR X=STARTADR I EPROM
*
RDPROM PSHS CC,A,B,X,Y
 ORCC #%01010000
 STB EPRLNK
 BSR READ4B
 TFR X,D
 ORA WRKSPC+2
 TFR D,Y
RDPR1 LDX #EPRSTR
 LDB #6
 BSR RDSTAT
 LDD EPREND
 ADDD EPROFF
 STD EPREND
 LDD EPRTFR
 ADDD EPROFF
 STD EPRTFR
 LDD EPRSTR
 ADDD EPROFF
 CLR EPROFF
 CLR EPROFF+1
 TFR D,X
EPRD1 STY PRMADR
 LDA PRMDAT
 STA 0,X+
 LEAY 1,Y
 CMPY WRKSPC        SIDSTE BYTE I EPROM
 BEQ EPRD3
EPRD2 CMPX EPREND   SIDSTE BYTE I PROGRAM
 BLS EPRD1
 LDX EPRTFR
 CMPX #$FFFF        FLERE FILER
 BNE EPEND          NEJ
 BRA RDPR1
EPEND PULS CC,A,B,X,Y
 JMP [EPRTFR]

EPRD3 BSR READ4B    L[S NY EPROM
 BRA EPRD2

READ4B PSHS X
 LDB EPRLNK
 STB PROMNR         NY EPROM
 LDX #WRKSPC
 LDY #$FFFC
 LDB #4             HENT 4 BYTE
 BSR RDSTAT
 LDA WRKSPC+3
 STA EPRLNK
 LDA WRKSPC+2
 ORA WRKSPC
 STA WRKSPC
 LDA WRKSPC+2
 CLRB
 TFR D,Y
 PULS X,PC

RDSTAT STY PRMADR
 LEAY 1,Y
 LDA PRMDAT         HENT BYTE
 STA 0,X+
 DECB
 BNE RDSTAT
 RTS

** L[S USER COMMAND TABEL FRA EPROM
*
RDUSCM LDB #12
 LDY #CMDCAT        START COMMAND CATALOG
 STB PROMNR
RDUSL0 LDX #$C844         SYSFCB
RDUSL1 STY PRMADR
 LDA PRMDAT
 BEQ CMTBFU         SLUT COMMAND EPROM
 CMPA #$FF          SLUT EPROMTABEL
 BEQ CMNTFN
 CMPA 0,X+
 BNE RDUSL2
 LEAY 1,Y           JA CHAR ENS
 BRA RDUSL1

RDUSL2 STY PRMADR
 LEAY 1,Y
 LDA PRMDAT
 BNE RDUSL2
RDUSL3 LEAY 3,Y
 BRA RDUSL0

RDUSL5 LEAY 4,Y
 BRA RDUSL0

CMTBFU CMPA 0,X
 BNE RDUSL5
 LEAY 1,Y
 LDX #WRKSPC
 LDB #3
CMFU1 STY PRMADR
 LDA PRMDAT
 STA 0,X+
 DECB
 BEQ RDUSL4
 LEAY 1,Y
 BRA CMFU1
RDUSL4 LDB WRKSPC
 LDX WRKSPC+1
 LEAS 5,S           CLEAR STACK
 JMP RDPROM
CMNTFN RTS

BNR FCB $11

TSTR12 PSHS A
 LDB #12
 LDX #$0000
 STB PROMNR
 STX PRMADR
 LDA PRMDAT
 STA EXTBYT
 CMPA BNR
TSTRRT PULS A,PC

SYSMON LDA EXTBYT
 CMPA BNR
 LBNE IOINT1
 JMP SYSMO2

** NMIIRQ ROUTINE
*
NMISER ORCC #%01010000
 LDA $E078          CLEAR IRQ
 LDA #$0C           S[T SYSTEM RAM
 STA IC11+$C
 INCA
 STA IC11+$D
 INC RTCLOC
 JSR SETL25
 LDY #NMITEK
 BSR PRYDAT
 LDA 0,S            CC-REG
 JSR OUT2H
 BSR PRYDAT
 LDA 1,S            A-REG
 JSR OUT2H
 BSR PRYDAT
 LDA 2,S            B-REG
 JSR OUT2H
 BSR PRYDAT
 LDA 3,S            DP-REG
 JSR OUT2H
 BSR PRYDAT
 LDX 4,S            X-REG
 JSR OUT4HT
 BSR PRYDAT
 LDX 6,S            Y-REG
 JSR OUT4HT
 BSR PRYDAT
 LDX 8,S            U-REG
 JSR OUT4HT
 BSR PRYDAT
 LDX 10,S           PC
 JSR OUT4HT
 BSR PRYDAT

NMI3 JSR INCHNO
 CMPA #'F
 BEQ NMI5
 CMPA #'R
 BEQ NMI31
 CMPA #'C
 BEQ NMI4
 BRA NMI3
NMI31 LDA #$7F      CLEAR IRQ FRA VIA
 STA VIA+$E
 JSR NORTC
 JMP INSTRM

** CONTINUE
*
NMI4 BSR CLRL25         CLEAR STATUS LINE
 DEC RTCLOC
 RTI

** JUMP FLEX
*
NMI5 BSR CLRL25
 DEC RTCLOC
 PULS CC
 JMP $CD03

** PRINT DATA [Y-REG]
*
PRYDAT LDA 0,Y+
 BEQ PRYDEN
 JSR OUTCH
 BRA PRYDAT
PRYDEN RTS

** OUTPUT CHR P] LINE 25
*
OCHL25 LDX CURADR
 TST CLKBYT
 BEQ OCHL20
 CMPX RTCLOC
 BEQ OCHLEN
OCHL20 STA 0,X+
 CMPX #$F000
 BNE OCHL22
OCHL21 LEAX -1,X
OCHL22 STX CURADR
 JSR SETCUR
OCHLEN JMP OUTRTS

** S[T FUNKTION P] LINE 25
*
SETL25 PSHS A,X
 JSR STCUR
 BSR CLSTAT
 LDX #LINE25
 STX CURADR
 JSR SETCUR
 JSR SETFUN
 LDX #OCHL25
 STX OUTADR
 PULS A,X,PC

** CLEAR FUNKTION P] LINE 25
*
CLRL25 PSHS A,X
 JSR CLRFUN
 BSR CLSTAT
 JSR LDCUR
 LDX #OUTCHR
 STX OUTADR
 PULS A,X,PC

** CLEAR LINE 25
*
CLSTAT PSHS A,X
 TST CLKBYT
 BEQ CLBOT1
 LDX #LINE25+71
 CMPX RTCLOC        CLOCK P] LINE25 ?
 BEQ CLST1
CLBOT1 LDX #$F000
CLST1 STX WRKSPC
 LDX #LINE25
 STX CURADR
 CLR LINCON
 LDA #$20
CLST2 STA 0,X+
 CMPX WRKSPC
 BNE CLST2
 PULS A,X,PC
CLBOTT PSHS A,X
 BRA CLBOT1

NMITEK FCC 'CC=',0,' A=',0,' B=',0,' DP=',0
 FCC ' X=',0,' Y=',0,' U=',0,' PC=',0
 FCC ' . C/F/R ?',0

FUNKMG FCC 'FUNK ? ',0

POCHK LDA $E009
POCD LDX #$FFFF
POD1 DEX
 BNE POD1
POCH1 LDA $E008
 BITA #$01
 RTS

SYSMO2 LDB #12
 LDX #$0001
 JMP RDPROM

DDPRT LDA $CCE4
 CMPA #$39
 BEQ DDPEND
 JSR $CCE4
DDPEND JMP OUTCH

*DISKIO SOURCE
* SELECT PROPER DRIVERS FROM REQUESTED DRIVE NUMBER

*ENTRY 4 DRIVE REFERENCE DRIVE ROUTINES
DRIVE
 PSHS D,U,PC DUMMY U & PC PLACE HOLDERS
 INC NESTCT KEEP TRK OF ENTRIES 4 NESTED CALLS
 BNE DIO1
 LDA 3,X GET GLOBAL DRIVE #
 STA GDRIVE SAVE IT
DIO1
 LDD 6,S MOVE DUMMY RTN ADDR
 STD 2,S PAST RTN ADDR
 STX 6,S TEMP STORAGE 4 X
 LDD #DRVRTN ADJUST RTN FROM DRIVERS
 STD 4,S PUT IN STACK
 PULS D RESTORE & FALL THROUGH

*ENTRY FOR NON-DRIVE REFERENCE DRIVE ROUTINES
DISKIO
 PSHS D,Y SAVE
 LDA GDRIVE GET GLOBAL DRIVE
 CMPA #3 TOP LIMIT FLEX DEFN
 BHI ERROR
 ASLA *2 BYTES /ENTRY
 LDY #DIOVEC DRIVE TABLE
 LDD A,Y DRV TYPE & LOGICAL DRIVE
 CMPA NDRVRS # OF DRIVE TYPES
 BHI ERROR EXCEEDED TABLE
 TSTB CK 4 NON EXISTANT DRV
 BMI ERROR
 STB LDRIVE UPDATE LOCAL DRV
 TST NESTCT DRIVE # ACCES?
 BNE DIO2 NO - SKIP
 STB 3,X SET LOCAL DR # IN FCB 4 DRIVERS
DIO2
 ASLA *2
 ASLA *4 ITEMS / ENTRY
 LDY #TYPTBL PT TO VECTOR TABLE
 LEAY A,Y PT Y TO DRIVE VECTOR
 LDA LDRIVE RECOVER 4 CK
 CMPA 2,Y CK 4 LDRIVE TOO LARGE
 BHI ERROR
 LDY ,Y GET ACTUAL ADDR OF VECTOR
 LDB 5,S RTN ADDR
 SUBB #3 CORRECT FOR OFFSET
 LEAY B,Y ADD TO Y FOR JUMP ADDR
 STY 4,S JUMP VECTOR ON STACK
 PULS D,Y,PC RESTORE & JUMP

*RETURN FROM DRIVE REF DISK ROUTINES
*(NON-DRIVE REFERENCE ROUTINES DIRECTLY TO CALLER)
DRVRTN
 PULS X RESTORE X
 PSHS CC SAVE ERROR FLAG
 DEC NESTCT DEC NEXT COUNT
 BPL DIO4 BRA IF NOT RETURNING TO FLEX
 LDA GDRIVE RESTORE GLOBAL
 STA 3,X DRIVE IN FCB
DIO4
 PULS CC,PC BACK TO FLEX

*BAD CAHKL EXIT
ERROR
 PULS D,Y RESTORE
 LEAS 2,S CLEAN UP RTS FROM ENTRY
 LDB #$0F NO SUCH DRIVE
 SEC FLAG ERROR
 RTS DONE

COLD JSR GCOLD
 BSR VECVIR+$15
 RTS

VECVIR
 LBRA READV
 LBRA WRITV
 LBRA VERIFV
 LBRA RESTOV
 LBRA DRIVEV
 LBRA CKRDYV
 LBRA QUICKV
 LBRA DINITV

READV
 PSHS CC
 ORCC #%01010000
 BSR SETDAT
 EXG X,Y
 BSR COPYXY
 BRA RESDAT
WRITV PSHS CC
 ORCC #%01010000
 BSR SETDAT
 BSR COPYXY
RESDAT
 LDA LRARAM
 STA IC11
 LDA LRARAM+2
 STA IC11+2
 PULS CC
 LDB #0
 CLC
 RTS
COPYXY
 LDB #128
 PSHS B
LOOP
 LDD ,X++
 STD ,Y++
 DEC ,S
 BNE LOOP
 PULS B,PC
SETDAT
 DECB
 CMPB #15
 BHI SEEKER
 CMPA TRACKS
 BHI SEEKER
 ADDA #$10
 CMPX #$1000
 BLO SD1
 STA IC11
 BRA SD2
SD1
 STA IC11+2
 ADDB #$20
SD2
 TFR B,A
 CLRB
 TFR D,Y
 RTS
SEEKER
 LEAS 2,S
 PULS CC
 LDB #$10
 SEC
 RTS

VERIFV
RESTOV
DRIVEV
CKRDYV
QUICKV
DINITV
DSEEKV
 CLRB
 RTS


